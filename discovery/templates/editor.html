{% extends "main.html" %}
{% block content %}
{% include "header.html" %}
<style>
.clsContainer{
  min-width: 45%;
  border-radius: 20px;
  box-shadow: 2px 2px 5px #bbbbbb;
  transition: .5s all;
  background: #eceaea !important;
}

.clsContainer:hover{
  background: white !important;
  box-shadow: 2px 2px 1px #bbbbbb;
  cursor: default;
}

.clsNameContainer{
  display: flex;
  word-break: break-all;
  justify-content: center;
  flex-direction: row;
  text-align: center;
}
.clsNameContainer div{
  flex: 1;
}

#schemaName1{
  background: none !important;
  box-shadow: none !important;
  text-align: center !important;
  font-size: 2em !important;
  color: #006476;
}

#schemaName1:focus{
  background: white !important;
}
</style>
<section id="editor" class="container" style="min-height: 70vh;padding-top:60px;">
  <div>
    <div class="jumbotron animatedBack text-center mt-5">
      <h1 class="text-light">Schema Editor</h1>
    </div>
    <div v-if=loading class="loader">
      <h1 class="mainTextLight"><i class="fas fa-cog"></i> Loading...</h1>
    </div>
    <div class="jumbotron">
      <h2 class="text-muted text-center">1. Define new classes and properties for your schema</h2>
      <div class="form-group text-center p-5">
        <input autocomplete="true" type="text" v-model='schemaName' class="form-control w-50 m-auto" id="schemaName1" aria-describedby="nameHelp" placeholder="Enter schema name">
        <small id="nameHelp" class="form-text text-muted">Choose a meaninful name for your schema. eg. Dataset, Contact, etc.</small>
      </div>
      <div class="p-2 mb-3 text-center">
        <button class="btn btn-success text-light" @click.prevent="addClass">Add Class <i class="fas fa-plus"></i></button>
      </div>
      <div class="text-center">
        <template v-for="(item,index) in myClasses">
          <class-box key="index" :clss="item" :myclass="true"></class-box>
        </template>
      </div>
    </div>
    <div class="jumbotron d-flex flex-wrap align-items-start">
      <div style="flex:1; min-width:100%;">
        <h2 class="text-muted text-center">2. Choose which parent class properties you want to resuse</h2>
      </div>
      <template v-for="(item,index) in clses">
        <class-box key="index" :clss="item"></class-box>
      </template>
    </div>
    <div class="jumbotron text-center">
      <h2 class="text-muted text-center">3. Generate Code</h2>
      <small class="text-muted d-block">Click here to see latest changes</small>
      <button class="btn themeButton pulse text-light" @click.prevent="generateResult">Get Your Code</button>
      <div v-show="valid" class="swing-in-left-fwd ">
        <pre >
          <code class="p-5 border-success" id="resultCode" @click="selectText('resultCode')">
          </code>
        </pre>
      </div>
    </div>

  </div>

</section>
{% endblock %}
{% block extra_scripts %}
<script src="https://unpkg.com/vuex"></script>
<script src="./static/js/lodash.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/axios/0.18.0/axios.min.js"></script>
<script src="https://unpkg.com/tippy.js@3/dist/tippy.all.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/sweetalert2@7.28.11/dist/sweetalert2.all.min.js"></script>
<script>

const store = new Vuex.Store({
  state: {
    // can access directly but not mutate using this.$store.state.count
    'schema':{},
    'userClasses':[]
  },
  strict: true,
  mutations: {
    saveSchema(state,payload){
      console.log('saving..')
      state.schema = payload['schema'];
    },
    saveClass(state,payload){
      clss = payload['clss'];
      if (state.schema['@graph']) {
        state.schema['@graph'].unshift(clss);
        state.userClasses.unshift(clss);
      }
    },
    removeClass(state,payload){
      clss = payload['clss'];
      if (state.schema['@graph']) {
        state.schema['@graph']= _.difference(state.schema['@graph'], [clss]);;
        state.userClasses= _.difference(state.userClasses, [clss]);;
      }
    },
    saveProperty(state,payload){
      prop = payload['prop'];
      if (state.schema['@graph']) {
        state.schema['@graph'].push(prop);
      }
    },
    removeProperty(state,payload){
      prop = payload['prop'];
      if (state.schema['@graph']) {
        for (var i = 0; i < state.schema['@graph'].length; i++) {
          if(state.schema['@graph'][i].hasOwnProperty('@type') && state.schema['@graph'][i]['@type'] === "rdf:Property"){
            let propObj = state.schema['@graph'][i];
            if (state.schema['@graph'][i]['rdfs:label']===prop['rdfs:label']) {
              state.schema['@graph'].splice(i, 1)
            }
          }
        }
      }
    }
  },
  getters:{
    // exposed as store.getters.nameOfGetter
    getClassList:state=>{
      return state.clssList
    },
    getSchema:state=>{
      return state.schema
    },
    getUserClasses:state=>{
      return state.userClasses
    },
  },
  actions:{

  }
});

Vue.component('description', {
  props: ['content'],
  data: function(){
    return{
      full:true ,
      text:''
    }
  },
  watch:{
    full:function(n,o){
      if (n) {
        this.text = this.content
      }else{
        if (this.content) {
          this.text = this.content.substring(0, 40);
        }
      }
    }
  },
  mounted:function(){
    this.full = false;
  },
  template: `<small class="pointer d-block" v-on:click="clicked">
              <span v-text="text"></span>
              <i v-if="!full && text.length>39" class="far fa-plus-square mainTextDark pointer"></i>
              <i v-if="full && text.length>39" class="far fa-minus-square mainTextLight pointer"></i>
            </small>`,
  methods: {
    clicked: function() {
      this.full=!this.full
    }
  }
});


Vue.component('class-box', {
  data: function(){
    return{
      showAll:true,
      myList:[],
      isHidden:true
    }
  },
  props: ['clss','myclass'],
  methods:{
      deleteClass(){
        var payload={};
        payload['clss'] = clss;
        store.commit('removeClass',payload)
      },
      toggleHide(){
        this.isHidden = ! this.isHidden
      },
      getName(classInfo){
        if (classInfo && classInfo.hasOwnProperty('rdfs:label')) {
          if (_.isPlainObject(classInfo['rdfs:label'])){
            return classInfo['rdfs:label']['@value']
          }else if (_.isString(classInfo['rdfs:label'])){
            return classInfo['rdfs:label']
          }
        }
      },
      addPropsToClass:function(){
        var self = this;
        var schema= store.getters.getSchema;
        let list={};
        if (schema && schema['@graph']) {
          for (var i = 0; i < schema['@graph'].length; i++) {
            if(schema['@graph'][i].hasOwnProperty('@type') && schema['@graph'][i]['@type'] === "rdfs:Class"){
              list[schema['@graph'][i]['@id']]= schema['@graph'][i]['@id']
            }
          }
        }

        Swal.mixin({
        input: 'text',
        confirmButtonText: 'Next &rarr;',
        showCancelButton: true,
        progressSteps: ['1', '2','3',]
      }).queue([
        {
          title: "Choose a name for your property",
          html: 'input name must be camel cased <b class="text-danger">eg. myProperty </b>',
          inputValidator: (value) => {
            return new Promise((resolve) => {
              if (value.match(/^[a-z]+(?:[A-Z][a-z]+)*$/)) {
                resolve()
              } else {
                resolve('class names must be PascalCased')
              }
            })
          }
        },
        {
          title: "What is this property's expected type?",
          input: 'select',
          inputOptions: list,
          html: 'input name(s) must be Pascal cased <b class="text-danger">eg. MyClass </b>'
        },
        {
          title: "Describe this property",
          html: 'write a short summary about this class',
          inputValidator: (value) => {
            return new Promise((resolve) => {
              if (!value.length<10) {
                resolve()
              } else {
                resolve('Comment is too short. 10 characters minimum.')
              }
            })
          }
        },
      ]).then((result) => {
        if (result.value) {
          this.handleUserPropInput(result.value);
        }
      })
    },
    handleUserPropInput: function(value, oldValue){
        var self = this;
        var skeleton={
          "@id": "schema:"+value[0],
          "@type": "rdf:Property",
          "rdfs:comment": value[2],
          "rdfs:label": value[0],
          "schema:domainIncludes": {
              "@id": self.clss['@id']
          },
          "schema:rangeIncludes": {
              "@id": "schema:"+value[1]
          }
        };
        // push to store
        var payload = {};
        payload["prop"] = skeleton;
        store.commit('saveProperty',payload);
    },
    removeProp(prop){
      var payload={};
      payload['prop'] = prop;
      store.commit('removeProperty',payload)
    },
    getType: function(data){
      let types=[];
      if (data.hasOwnProperty("schema:rangeIncludes")) {
        if (_.isString(data["schema:rangeIncludes"])) {
          let type = data['schema:rangeIncludes'].split(':');
          type = type[type.length-1];
          types.push(type);
        }
        else if (_.isArray(data["schema:rangeIncludes"])) {
          for (var i = 0; i < data['schema:rangeIncludes'].length; i++) {
            let type = data['schema:rangeIncludes'][i]['@id'].split(':');
            type = type[type.length-1];
            types.push(type);
          }
        }else if(_.isObject(data["schema:rangeIncludes"])){
          let type = data['schema:rangeIncludes']['@id'].split(':');
          type = type[type.length-1];
          types.push(type);
        }
      }
      return types;
    },
    getSubclass: function(data){
      let subclasses=[];
      if (data.hasOwnProperty("rdfs:subClassOf")) {
        if (_.isString(data["rdfs:subClassOf"])) {
          let cl = data['rdfs:subClassOf']
          subclasses.push(cl);
        }
        else if (_.isArray(data["rdfs:subClassOf"])) {
          for (var i = 0; i < data['rdfs:subClassOf'].length; i++) {
            let cl = data['rdfs:subClassOf'][i]['@id']
            subclasses.push(cl);
          }
        }else if(_.isObject(data["rdfs:subClassOf"])){
          let cl = data['rdfs:subClassOf']['@id']
          subclasses.push(cl);
        }
      }else{
        subclasses.push('This class has no subclass');
      }
      return subclasses;
    },
  },
  watch:{
    showAll: function(newVal, oldVal){
      if (newVal) {
        this.myList = this.properties;
      }else{
        this.myList = this.properties.slice(0,5);
      }
    }
  },
  mounted: function(){
    this.showAll= false
  },
  computed: {
    className:function(){
      return this.clss['rdfs:label'];
    },
    properties:function(){
      let schema = store.getters.getSchema;
      let props =[];
      var self= this;
      for (var i = 0; i < schema['@graph'].length; i++) {
        if(schema['@graph'][i].hasOwnProperty('@type') && schema['@graph'][i]['@type'] === "rdf:Property"){
          let propObj = schema['@graph'][i];
          if ( _.isString(propObj['schema:domainIncludes']) ) {
            if (propObj["schema:domainIncludes"].includes(self.className)) {
              props.push(propObj);
            }
          }
          else if ( _.isArray(propObj['schema:domainIncludes']) ) {
            for (var j = 0; j < propObj['schema:domainIncludes'].length; j++) {
              if (propObj["schema:domainIncludes"][j]['@id'].includes(self.className)) {
                props.push(propObj);
              }
            }
          }else if( _.isPlainObject(propObj['schema:domainIncludes']) ){
            if (propObj["schema:domainIncludes"]['@id'].includes(self.className)) {
              props.push(propObj);
            }
          }

        }
      }
      return props;
    }
  },
  template:
  `<div class="clsContainer p-3 bg-light m-3" style="position:relative;" style="flex:1">
    <i v-if="myclass" @click.prevent="deleteClass" title="DELETE" class="fas fa-times text-danger pointer" style="position:absolute; right:10px; top:10px;"></i>
    <div class="row">
      <div class="clsNameContainer col-sm-12">
        <div class='text-center'>
          <h5 @click.prevent='toggleHide' class="mainTextDark d-inline pointer" v-text="clss['rdfs:label']" :title="clss['rdfs:comment']"></h5>
          <span class="badge text-light" :class="[ properties.length>0 ? 'mainBackLight' : 'bg-secondary']" v-text="properties.length"></span>
          <br />
          <small class="text-muted">
            <span v-if="clss['rdfs:subClassOf']">Subclass of:</span>
            <template v-for="item in getSubclass(clss)">
              <small class="bold mainTextDark mr-2" v-text='item'></small>
            </template>
          </small>
          <div class="text-center" v-if='myclass'>
              <a role='button' class="btn smallButton bg-success text-light" @click.prevent="addPropsToClass">Add Property <i class="fas fa-plus"></i></a>
          </div>
        </div>
      </div>
      <div v-show='!isHidden' class="propContainer  text-muted col-sm-12">
        <small>
          PROPERTIES
        </small>
        <table class="w-100 table table-sm table-responsive-sm" v-if="properties.length">
          <thead class="mainBackLight text-light">
            <th class="text-center">
              <small>Remove</small>
            </th>
            <th>
              <small>Name</small>
            </th>
            <th>
              <small>Comment</small>
            </th>
            <th>
              <small>Expected Type</small>
            </th>
          </thead>
          <tbody>
            <template v-for="(item,index) in myList">
              <tr>
                <td class="text-center">
                  <i :title="'Remove '+item['rdfs:label']" class="fas fa-minus-circle text-danger pointer" @click.prevent="removeProp(item)"></i>
                </td>
                <td>
                  <span v-text='getName(item)'></span>
                </td>
                <td class="p-2">
                  <description :content='item["rdfs:comment"]'></description>
                </td>
                <td>
                  <template v-for="(type,i) in getType(item)">
                    <small class="mr-2" v-html='type'></small>
                  </template>
                </td>
              </tr>
            </template>
            <template v-if="!showAll && properties.length>5">
              <tr class="text-center">
                <td colspan='4' class='text-center'>
                  <a role="button" class="btn smallButton mainBackLight text-light" @click.prevent="showAll= !showAll">Show More (<span class="bold" v-text="properties.length-5"></span>)</a>
                </td>
              </tr>
            </template>
            <template v-if="showAll">
              <tr class="text-center">
                <td colspan='4' class='text-center'>
                  <a role="button" class="btn smallButton mainBackLight text-light" @click.prevent="showAll= !showAll">Show Less</a>
                </td>
              </tr>
            </template>
          </tbody>
        </table>
        <div v-else class="bg-secondary text-light text-center">
          <small>This class has no properties of its own</small>
        </div>
      </div>
    </div>
  </div>`
});

var app = new Vue({
      el: '#editor',
      store: store,
			data: function(){
				return {
          loading: false,
          valid: false,
          code: null,
          url:'',
          handleUserClassInput:[],
          editFrom:'',
          schemaName:''
				}
			},
      computed:{
        clses:function(){
          var schema= store.getters.getSchema;
          let clssList=[];
          if (schema && schema['@graph']) {
            for (var i = 0; i < schema['@graph'].length; i++) {
              if(schema['@graph'][i].hasOwnProperty('@type') && schema['@graph'][i]['@type'] === "rdfs:Class"){
                clssList.push(schema['@graph'][i])
              }
            }
          }
          return _.difference(clssList, this.myClasses)
        },
        myClasses:{
          get(){
            return store.getters.getUserClasses
          }
        }
      },
      watch:{
        handleUserClassInput: function(value, oldValue){
          var self = this;
          console.log('VALUE', value)
          var skeleton={
            "@id": value[2]+":"+value[0],
            "@type": "rdfs:Class",
            "rdfs:comment": value[3],
            "rdfs:label": value[0],
            "rdfs:subClassOf": {
                "@id": value[1]
            }
          };
          // push to store
          var payload = {};
          payload["clss"] = skeleton;
          store.commit('saveClass',payload);
        }
      },
			methods:{
        handleSubmit(){
          var self = this;
          if (self.url) {
            axios.get(self.url).then(res=>{
              console.log(res.data)
            }).catch(err=>{
              throw err;
            });
          }
        },
        selectText(containerid) {
          window.getSelection().selectAllChildren( document.getElementById( containerid ) );
        },
        loadingOn(){
          var self = this;
          self.loading = true;
        },
        loadingOff(){
          var self = this;
          self.loading = false;
        },
        generateResult(){
          var self = this;
          let schema = store.getters.getSchema;
          if (schema) {
            self.valid= true;
            self.code = JSON.stringify(schema, null, 2);
            document.getElementById("resultCode").textContent= self.code;
          }else{
            self.valid = false;
          }
        },
        addClass:function(){
          var self = this;
          var schema= store.getters.getSchema;
          let list={};
          if (schema && schema['@graph']) {
            for (var i = 0; i < schema['@graph'].length; i++) {
              if(schema['@graph'][i].hasOwnProperty('@type') && schema['@graph'][i]['@type'] === "rdfs:Class"){
                list[schema['@graph'][i]['@id']]= schema['@graph'][i]['@id']
              }
            }
          }

          Swal.mixin({
          input: 'text',
          confirmButtonText: 'Next &rarr;',
          showCancelButton: true,
          progressSteps: ['1', '2','3','4']
        }).queue([
          {
            title: "Choose a name for your class",
            html: 'input name must be Pascal cased <b class="text-danger">eg. MyClass </b>',
            inputValidator: (value) => {
              return new Promise((resolve) => {
                if (value.match(/^[A-Z][a-z]+(?:[A-Z][a-z]+)*$/)) {
                  resolve()
                } else {
                  resolve('class names must be PascalCased')
                }
              })
            }
          },
          {
            title: "What is this class' subclass?",
            input: 'select',
            inputOptions: list,
            html: 'input name must be Pascal cased <b class="text-danger">eg. Thing </b>'
          },
          {
            title: "Choose a namespace for your schema",
            html: `<p>
                    The namespace chosen will resolve to your schema when expanded, for example:
                    <br />
                    <small>  http://discovery.biothings.io/<b class="text-danger">your-namespace</b>/SchemaName</small>
                   </p>`,
            showLoaderOnConfirm: true,
            preConfirm: (value) => {
              return axios.get(`/api/query?q=_meta.slug:`+value).then(function (response) {
                console.log('slug check',response,value)
                if (response.data.total) {
                  throw new Error('namespace not available')
                }else if(!response.data.total){
                  return value
                }
              }).catch(error => {
                Swal.showValidationMessage(
                  `Request failed: ${error}`
                )
              });
             },
          },
          {
            title: "Write a comment about this class",
            html: 'write a short summary about this class',
            inputValidator: (value) => {
              return new Promise((resolve) => {
                if (!value.length<10) {
                  resolve()
                } else {
                  resolve('Comment is too short. 10 characters minimum.')
                }
              })
            }
          },
        ]).then((result) => {
          if (result.value) {
            this.handleUserClassInput= result.value;
          }
        })
        }
			},
			mounted:function(){
        var self = this;
        var schema = localStorage.getItem('datasetData');
        if (schema) {
          var payload = {};
          payload["schema"] = JSON.parse(schema);
          store.commit('saveSchema',payload);
        }
        localStorage.setItem('editFrom','CreativeWork');
        this.editFrom = localStorage.getItem('editFrom');

			}
		});

</script>
{% include "footer.html" %}
{% endblock %}
